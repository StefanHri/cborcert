use crate::csr::OutCSR;
use crate::error::CborCertError;
use crate::keygen::OutEd25519Data;
use itertools::Itertools;
use std::fs;

pub trait Saving {
    fn save(&self) -> Result<(), CborCertError>;
}

pub enum Out<'a> {
    OutEd25519(OutEd25519Data<'a>),
    OutCSR(OutCSR<'a>),
}

impl Saving for Out<'_> {
    fn save(&self) -> Result<(), CborCertError> {
        match self {
            Out::OutEd25519(ed25519_data) => ed25519_data.save(),
            Out::OutCSR(csr_data) => csr_data.save(),
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum FileFormat {
    C,
    DER,
    TOML,
}
pub struct File {
    pub full_name: String,
    pub name: String,
    pub format: FileFormat,
}

const C_HEADER: &str = "/*
    This file is automatically generated with cborcert.   
 ";
const ED25519_META: &str = "
    It contains random Ed25519 signature keys.
*/\n\n";
const CSR_META: &str = "
    It contains a Certificate Signing Request (CSR).
*/\n\n";

impl Saving for OutEd25519Data<'_> {
    fn save(&self) -> Result<(), CborCertError> {
        for file in self.out_files {
            match &file.format {
                FileFormat::C => {
                    fs::write(
                        format!("{}.c", file.name),
                        format!(
                            "{}{}const char sk []= {{ {:#04x} }};\n\nconst char pk []=  {{ {:#04x} }};\n\nconst unsigned int sk_len = sizeof(sk);\n\nconst unsigned int pk_len = sizeof(pk);",
                            C_HEADER,
                            ED25519_META,
                            self.sk.iter().format(", "),
                            self.pk.iter().format(", ")
                        ),
                    )?;
                }
                FileFormat::TOML => {
                    return Err(CborCertError::KeyCannotBeSavedInTomlFile);
                }
                FileFormat::DER => {
                    println!("file.name {}:", file.name);
                    fs::write(format!("{}_sk_ed25519.der", file.name), self.sk)?;
                    fs::write(format!("{}_pk_ed25519.der", file.name), self.pk)?;
                }
            }
        }
        Ok(())
    }
}

impl Saving for OutCSR<'_> {
    fn save(&self) -> Result<(), CborCertError> {
        for file in self.out_files {
            match &file.format {
                FileFormat::C => {
                    fs::write(
                        format!("{}.c", file.name),
                        format!(
                            "{}{}const char csr []= {{ {:#04x} }};\n\nconst unsigned int csr_len = sizeof(csr);",
                            C_HEADER,
                            CSR_META,
                            self.csr.iter().format(", "),
                        ),
                    )?;
                }
                FileFormat::TOML => {
                    return Err(CborCertError::CSRCannotBeSavedInTomlFile);
                }
                FileFormat::DER => {
                    println!("file.name {}:", file.name);
                    fs::write(format!("{}.der", file.name), &self.csr)?;
                }
            }
        }
        Ok(())
    }
}
